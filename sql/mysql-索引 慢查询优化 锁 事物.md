index

index type
	聚集index
		== 主键
		根据这个来组织数据存储(InnoDB)
		按照每张表的主键来构建一颗b+树,叶子节点存放整张表的行记录
	辅助索引(sencondary index,也称 非聚集索引)
		叶子节点包括{
			对应行记录,
			指针 (告诉存储引擎那可以找到对应的行记录,因此InnoDB的指针指向就是聚集索引键,
				查找是两次查找,辅助找一次,聚集找一次)
		}

	联合索引
		根据查询条件判断是新建联合索引,还是新建单一索引

新建索引的原则
	1.最左前缀匹配原则
	2.=和in可以乱序
	3.尽量选择区分度高的列作为索引
	4.索引列不能参与计算
	5.尽量的扩展索引，不要新建索引

sql select 使用索引的情况
	1. 左前缀原则
	2. = in 换原则
	3. 索引位数
	4. 覆盖索引与排序
		当索引中的列包含所有查询中需要使用到的列的时候,mysql就可以使用索引返回需要的数据,而无需查询对应的行
		在数据库中，如果无法利用索引完成排序，随着过滤数据的数据量的上升，排序的成本会越来越大，即使是采用了limit，但是数据库是会选择将结果集进行全部排序，再取排序后的limit 记录，而且MySQL 针对可以用索引完成排序的limit 有优化，更能减少成本

		查找遇到排序的时候总是先排序,order by中的字段一定要在最左前缀字段,这样索引构建的顺序
		才是依赖它构建的,排序的时候才不会用到filesort(若order by 字段使用索引,则直接检索出来的数据就是排序的,不用再使用filesort对已经检索出来的数据再次排序)

	5. 包含 > , < , between and ,like 回中断使用索引.后面的where查询列不会使用索引
	6. like "%abc" 不使用索引, like "abc%" 使用索引 

优化器不使用索引的情况

explain分析使用索引


-------------------- slow select
查询慢原因: 
	分析查询生命周期
基础优化
	是否向服务器请求了不需要的数据 
		eg: * 请求不需要的列,列优化 
	是否扫描了额外的数据
		explain type 显示: 主要使用索引优化
			聚集索引中使用where过滤--存储引擎完成
			索引覆盖扫描(extra using index) 	
				返回需要的记录(解释:从索引树种取数据,无需回表中查询)--服务层执行
			从数据表中查询(extra using where),查询完才过滤数据--服务层执行

重构查询
	切分查询
	分解关联查询

生命周期
	sql
	client---->查询缓存-->(解析器-->预处理器)-->优化器-->存储引擎-->数据
	
	client:show full processlist
	optimize:
		show status like 'last_query_cost'  优化器认为大约1024个数据页的随机查询才能完成上一条语句的查询


--------------------- 锁机制
实现事物隔离性要求

innoDB存储引擎中的锁
	类型(行):
		共享锁
		排他锁
	多粒度(granular)锁:
		行级锁
			record lock:单个行上锁
			gap lock
			next-key lock
		表级锁
		(行间锁属于行锁的一种)
		支持方式:
			意向锁(intention lock)
				多层上锁机制,若想对一行进行上锁,要先对对应的数据库上锁,表上锁(对行上排他锁,对数据库和表也上排他锁),
				意向锁之间不进行相互阻塞,即使都是意向排他锁.
	实现锁:
		一致性非锁定读,是指innodb通过多版本控制的方式(MVCC)读取当前执行时间的数据.











--------------------- 事物


隔离性
phantom(幻像) 问题
	phantom problem 是指在同一事物下,连续两次执行同样的sql,导致不同的结果,
	第二次sql可能返回之前不存在的结果
