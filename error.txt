error

................................................................
1.hibernate
Caused by: java.lang.ClassNotFoundException:
javax.persistence.EntityListene
用的是Hibernate3.6.0.final,
出现这个问题的可能原因是没有导入
hibernate-jpa-2.0-api-1.0.0.Final.jar这个包

.................................................................
2.eclipse
.报不知名的错误
Servlet.service() for servlet [jsp] in context with path
[/dew] threw exception [javax.servlet.Servl
解决：project ->clean ->清空当前服务器中的项目缓存。从起tomcat

..................................................................
3. java API
java.lang.NumberFormatException: For input string: ""
当你强制转换一个String为Integer时,
而这个String为""时的异常,即你的String不能转为Integer的异常

...........................................................................
4. struts，springMVC  中文乱码问题

url传值到Action的乱码解决方法：
	jsp页面 URL传中文参数到Action里面出现乱码，
用过滤器和控制器都解决不了，用了我两个多小时解决这个小问题！---------

原因：
默认情况下，tomcat使用的的编码方式：iso-8859-1

解决方法有以下几种：
第一种：在Action中用 new String(str.getBytes("ISO-8859-1"), "UTF-8")，进行转码，因为传递的时候，中文默人的是ISO-8859-1
					 new String(str.getBytes("GBK"), "ISO-8859-1")

第二种：可通过配置TOMCAT来解决此问题，具体解决方法如下：在tomcat的server.xml里，找到<Connector port="8080" 
              maxThreads="150" minSpareThreads="25" maxSpareThreads="75" 
              enableLookups="false" redirectPort="8443" acceptCount="100" 
              debug="0" connectionTimeout="20000" 
              disableUploadTimeout="true" useBodyEncodingForURI="true" URIEncoding="gbk">
其中是修改 disableUploadTimeout="true" useBodyEncodingForURI="true" URIEncoding="gbk" 其方法是防止在url中出现乱码
然后在每个Jsp页面添加如下代码
<%@ page pageEncoding=”gb2312″%>
<%@ page contentType=”text/html;charset=gb2312″%>
<%request.setCharacterEncoding(”gb2312″);%>

第三种：直接在ACTION中利用以下方法解决：request.setCharacterEncoding("gb2312");
        response.setCharacterEncoding("gb2312");

action,controller 返回页面的值乱码：
	前台传过来的参数
	str = new String(str.getBytes("ISO-8859-1"),"utf-8");
	返回前台的参数--下载文件时
	String str2 = new String(str.getBytes("GBK"), "ISO-8859-1");

getBytes方法：
	String的getBytes()方法是得到一个操作系统默认的编码格式的字节数组。
这个表示在不通OS下，返回的东西不一样！ 
	String.getBytes(String decode)方法会根据指定的decode编码返回某字符串在该编码下的byte数组表示，如
byte[] b_gbk = "中".getBytes("GBK"); 
byte[] b_utf8 = "中".getBytes("UTF-8");
byte[] b_iso88591 = "中".getBytes("ISO8859-1");
将分别返回“中”这个汉字在GBK、UTF-8和ISO8859-1编码下的byte数组表示，
此时b_gbk的长度为2，b_utf8的长度为3，b_iso88591的长度为1。 

	而与getBytes相对的，可以通过new String(byte[], decode)的方式来还原这个“中”字时，
这个new String(byte[], decode)实际是使用decode指定的编码来将byte[]解析成字符串。
String s_gbk = new String(b_gbk,"GBK");
String s_utf8 = new String(b_utf8,"UTF-8");
String s_iso88591 = new String(b_iso88591,"ISO8859-1");

通过打印s_gbk、s_utf8和s_iso88591，会发现，s_gbk和s_utf8都是“中”，而只有s_iso88591是一个不认识的字符，
为什么使用ISO8859-1编码再组合之后，无法还原“中”字呢，其实原因很简单，
因为ISO8859-1编码的编码表中，根本就没有包含汉字字符，
当然也就无法通过"中".getBytes("ISO8859-1");来得到正确的“中”字在ISO8859-1中的编码值了，
所以再通过new String()来还原就无从谈起了。
因此，通过String.getBytes(String decode)方法来得到byte[]时，
一定要确定decode的编码表中确实存在String表示的码值，这样得到的byte[]数组才能正确被还原。

------------------------为什么要转换编码：
有时候，为了让中文字符适应某些特殊要求（如http header头要求其内容必须为iso8859-1编码），
可能会通过将中文字符按照字节方式来编码的情况，如
String s_iso88591 = new String("中".getBytes("UTF-8"),"ISO8859-1")，
这样得到的s_iso8859-1字符串实际是三个在 ISO8859-1中的字符，在将这些字符传递到目的地后，
目的地程序再通过相反的方式
String s_utf8 = new String(s_iso88591.getBytes("ISO8859-1"),"UTF-8")
来得到正确的中文汉字“中”。这样就既保证了遵守协议规定、也支持中文。 

servlet规范：
(1) HttpServletRequest.setCharacterEncoding()方法 仅仅只适用于设置post提交的request body的编码而不是设置get方法提交的queryString的编码。该方法告诉应用服务器应该采用什么编码解析post传过来的内容。很多文章并没有说明这一点。
(2) HttpServletRequest.getPathInfo()返回的结果是由Servlet服务器解码(decode)过的。
(3) HttpServletRequest.getRequestURI()返回的字符串没有被Servlet服务器decoded过。
(4) POST提交的数据是作为request body的一部分。
(5) 网页的Http头中ContentType("text/html; charset=GBK")的作用：
    (a) 告诉浏览器网页中数据是什么编码；
    (b) 表单提交时，通常浏览器会根据ContentType指定的charset对表单中的数据编码，然后发送给服务器的。
这里需要注意的是：这里所说的ContentType是指http头的ContentType，而不是在网页中meta中的ContentType。

.......................................................................................
5 ctrl + c ??tomcat

......................................................................
6.required="true"
  stuts 标签。谨慎使用

..................................................................................
7.<A href="javascript:void(0)">点击</a>点击链接后不会回到网页顶部

.................................................................................
8. hibernate
No row with the given identifier exists
有两张表,table1和table2.
产生此问题的原因就是table1
里做了关联<one-to-one>或者<many-to-one unique="true">
(特殊的多对一映射,实际就是一对一)
来关联table2.当hibernate查找的时候,
table2里的数据没有与table1相匹配的,
这样就会报No row with the given identifier exists这个错.
(一句话,就是数据的问题!)

................................................................................
9.SQL Server 2005“备份集中的数据库备份与现有的数据库不同”解决方法
http://www.jb51.net/article/19233.htm

.................................................................................
10.
java.lang.NumberFormatException: For input string: ""
类型转换的问题
................................................................................

11. xgb 缓存
ClientAbortException: java.net.SocketException:
Connection reset by peer: socket write error
原因如下：
1、这个问题一般是客户端在连接还没有完全建立的时候就取消连接，
比如用户按了浏览器上面的“停止”按钮，一般来说没有什么问题。
但是如果频繁出现，就表示很多客户端连接到Apache服务器的响应时间太长了，
可能是网络的问题或者服务器性能问题 可能你的网络连接存在一些问题，
你的数据传输的时候，可能由于时间等待的太久，
但是server段设置的连接检验时间限制一定，
那么就可能出现这种情况的！ 
------------------------------------------------------
12、xgb 缓存
ClientAbortException: java.net.SocketException:
Connection reset by peer: socket write error
的原因是由于处理http连接时，正在输出内容时，
用户关闭了IE，会出现一个"ClientAbortException"，
属于I/O处理中出现的一个异常，应用服务器应该会捕捉。
3、应该是线程被占用的太多了 无法控制了 
我想可能会是：.数据库库连接达到极限
，.应用服务器 最大线程并发数 达到极限，.内存耗尽

.....................................................................................

13	string
奖惩查询时错误
   string强制转换int 时，null," " 不能被转换
....................................................................................
14.	缓存
socket write error
这个异常的原因是，你的页面有一些动态生成的东西，而且相对较大。
你的服务器向客户端发送数据，结果刚发一半，客户端关闭了链接，就造成了这个错误，

一般是类似验证码这样的地方。 总之这个异常是合理的，至于是否引起tomcat挂掉，我不认为是这个原因。

除非你的这部分程序有错误！

..............................................................................................
15.	缓存
Java heap space
tomcat缓存不足

...........................................................................................
16.	serlet
String filePath = request.getSession().getServletContext().getRealPath("/");
request.getSession().getServletContext() 获取的是Servlet容器对象，
相当于tomcat容器了。getRealPath("/") 获取实际路径，“/”指代项目根目录
，所以代码返回的是项目在容器中的实际发布运行的根路径如
：I:\workspace\.metadata\.plugins\org.eclipse.wst.server.core\tmp1\
wtpwebapps\UMPWeb_20131230\

....................................................................................
17.	eclipse 设置默认编码为Utf-8
需要设置的几处地方为：

 Window->Preferences->General ->Content Type->Text->JSP 最下面设置为UTF-8

 Window->Preferences->General->Workspace 面板Text file encoding 选择UTF-8
 Window->Preferences->Web->JSP Files面板选择 ISO 10646/Unicode(UTF-8)

....................................................................................
18.项目旁有!

    以前引用的包，因为路径的等问题
    找不到了
    buildpath就可以

..................................................................................
19	Tomcat
Tomcat报错：Document base ……does not exist or is not a readable directory
删除eclipse中的tomcat就好了

.................................................................................
20	log4j
log4j:ERROR LogMananger.repositorySelector was null likely due to error in class reloading, usin (2011-05-10 19:54:32)转载
标签： 杂谈	分类： javascript_SSH
Today I got this error message from Tomcat 6.0.24:
log4j:ERROR LogMananger.repositorySelector was null likely due to error
in class reloading, using NOPLoggerRepository.

The reason for the error is a new listener in Tomcat 6.0.24. You can fix this error by adding this line:
org.apache.catalina.loader.WebappClassLoader.ENABLE_CLEAR_REFERENCES=false
to the "conf/catalina.properties" file in your tomcat directory.

..........................................................................................
21 JSP
org.apache.jasper.JasperException: Unable to compile class for JSP: 

An error occurred at line: 23 in the generated java file
The method getJspApplicationContext(ServletContext) is undefined for the type JspFactory

项目中有像jsp-api.jar servlet-api.jar跟tomcat6的lib中同样的包，
但版本比tomcat6的版本要低，在运行的时候，因为会优先加载项目中的包，
所以 产生了错误，把项目中和tomcat相同的包删除(必须删除，如果替换还会产生其他的错误)，
问题就可以解决了。

............................................................................................................
22. 规范--wonders
方法命名规范：
1.java驼峰命名法，首字母以小写开头，每个单词首字母大写（第一个单词除外）
2.方法表示一种行为，它代表一种动作，最好是一个动词或者动词词组或者第一个单词为一个动词。
    页面跳转命名规则：to+XXX
    页面查询命名规则：query+XXX，find+XXX，get+XXX，load+XXX，search+XXX
    页面更新命名规则：update+XXX, modify+XXX
    页面保存命名规则：save+XXX
    页面删除命名规则：remove+XXX，delete+XXX

.............................................................................................................


