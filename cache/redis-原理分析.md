---
title: redis 原理 事物/应用场景/持久化
date:
categories:
- redis
tags:
- redis 事物
- redis 应用场景
---

## redis 问题  
    - 缓存淘汰策略  
    - 分布式事物锁  
    - 事务  
    - redis错误处理,网络断了,出问题应该怎么处理  
    - redis性能监控  
    - redis 缓存击穿,失效,热点key  

## 事务
http://redisbook.readthedocs.io/en/latest/feature/transaction.html  

Redis 通过 MULTI 、 DISCARD 、 EXEC 和 WATCH 四个命令来实现事务功能  
1. WATCH 命令用于在事务开始之前监视任意数量的键：  
 当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。

2. 事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。  
事务在执行过程中不会被中断，所有事务命令执行完之后，事务才能结束。
多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。  
3. 带 WATCH 命令的事务会将客户端和被监视的键在数据库的   `watched_keys`字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的 `REDIS_DIRTY_CAS` 选项打开。  
只有在客户端的 `REDIS_DIRTY_CAS` 选项未被打开时，才能执行事务，否则事务直接返回失败。  
4. Redis 的事务保证了 ACID 中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。  

## Redis的单线程属性
由于Redis是单线程机制，所以不会出现并发问题，所以可以将其作为：计数器，产生唯一ID，做秒杀系统。  


## MONITOR

## SLOWLOG 慢日志分析
通过SLOWLOG可以读取慢查询日志  
```
   127.0.0.1:6320> slowlog get 1    
        1) (integer) 394689     #slowlog的唯一编号    
        2) (integer) 1480851711     #此次slowlog事件的发生时间    
        3) (integer) 10639     #耗时    
        4) 1) "HGET"     #slowlog事件所对应的redis 命令    
           2) "hash:submit_sent_150004"    
           3) "15000429648122734363745165312"  
```  
分析:
  1. redis使用单线程处理客户端的请求，结果是，当请求缓慢服务时，所有其他客户端将等待这个请求被服务。如果需要执行很多的slow commands，建议把slow queries放到redis slave上去执行。  
  2. 关于keys命令：执行慢速命令所产生的非常常见的延迟源是在生产环境中使用KEYS命令。   如Redis文档中所述，KEYS应该只用于调试目的。  
SCAN:  
    SCAN是基于游标的迭代器。 这意味着在每次调用命令时，服务器返回一个更新的游标，用户需要在下一次调用中用作游标参数。  
    当游标设置为0时，迭代开始，并且当服务器返回的游标为0时终止迭代。  

## redis延迟时间排查  
定义:  
    延迟指的是客户端从发送命令到接收命令回复这段时间的最大值  
测试一下redis的响应速度：  
    ```redis-cli --latency -h xxx -p xxxx  ```  
这条命令会向Redis插入示例数据来检查平均延时。 Ctrl+C可以随时结束测试；  
出现延时的可能:  
硬件  
网络  
Redis命令：  
1. 一些时间复杂度比较高的命令，如 lrem，sort，sunion等命令会花比较长时间；另外，大量的重复连接也会造成延时，重用连接是一种很好的品质；如果有大量写操作，可以使用 pipeline管道的方式（类似mysql事务），一次性提交，这样数据量也少了，连接次数也少了，不用每次都返回数据，  
2. 速度自然会快很多；  
3. 一个非常常见的造成Redis响应延迟的情况是在生产环境中使用KEYS命令  
使用单线程的一个结果是，当一个请求的处理很慢时，所有其他客户端将等待该请求被处理完毕。  

## Redis持久化：
1. Redis持久化需要fork出一个进程来进行持久化操作，这本身就会引发延时，如果数据变化大，RDB配置时间短，  
那这个代价还是挺大的；再加上，硬盘这东西真有点不靠谱，如果还是虚拟机上的虚拟硬盘，如果还是NFS共享目录，那这延时会让你崩溃。所以，如果系统不需要持久化，关了吧。  

2. Redis有两种持久化的方式：快照（RDB文件）和追加式文件（AOF文件）：   
  1) RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。  
  2) AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。

3. Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。
两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。

4. RDB  
    1. 优点  
      RDB的性能很好，需要进行持久化时，主进程会fork一个子进程出来，  
      然后把持久化的工作交给子进程，自己不会有相关的I/O操作。  
      比起AOF，在数据量比较大的情况下，RDB的启动速度更快。  
    2. 缺点  
        RDB容易造成数据的丢失。假设每5分钟保存一次快照，如果Redis因为某些原因不能正常工作，  
        那么从上次产生快照到Redis出现问题这段时间的数据就会丢失了。  
        RDB使用fork()产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成Redis停止服务几毫秒。如果数据量很大且CPU性能不是很好的时候，停止服务的时间甚至会到1秒。  
    3. 保存点（RDB的启用和禁用）  
        配置保存点，使Redis如果在每N秒后数据发生了M次改变就保存快照文件。  
        例如下面这个保存点配置表示每60秒，如果数据发生了1000次以上的变动，  
        Redis就会自动保存快照文件：   
            save 60 1000  
        禁用快照保存  
            save ""  
        保存点可以设置多个，Redis的配置文件就默认设置了3个保存点：

## 持久化和延迟/性能的权衡  
为了在后台生成RDB文件，或者当AOF持久化开启时重写AOF文件，Redis需要执行fork。  
fork操作（在主线程中执行）会引发响应延迟。  
1. AOF + fsync always: 非常慢，只有当你确实需要时才使用该配置。  
2. AOF + fsync every second: 一个比较均衡的选择。  
3. AOF + fsync every second +no-appendfsync-on-rewrite选项为yes:也是一个比较均衡的选择，但是要避免重写期间执行fsync，  
这可以降低磁盘压力。  
4. AOF + fsync never: 将fsync操作交给内核，减少了对磁盘的压力和延迟。  
5. RDB: 这里你可以配置触发生成RDB文件的条件。  

## 关闭主服务器持久化时，复制功能的数据安全  
禁止主服务器关闭持久化的同时自动拉起。  
在关闭主服务器上的持久化，并同时开启自动拉起进程的情况下，即便使用Sentinel来实现Redis的高可用性，也是非常危险的。  
因为主服务器可能拉起得非常快，以至于Sentinel在配置的心跳时间间隔内没有检测到主服务器已被重启，然后还是会执行上面的数据丢失的流程。  

## redis 使用场景       
1. string  
    String是二进制安全的。它可以包含任何数据，图片或者其他序列化后的对象  

2. hash  
    hash特别适合用于存储对象,替代对象序列化/反序列化  

3. list   
    Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。  
    List即可以作为栈，也可以作为队列。       
    最新列表  
4. set  
    无序,不重复(自动去除重复)  
    集合提供了求交集、并集、差集  

    求共同关注,相同关注等  

5. Sorted Set zset  
      增加了一个权重参数score，使得集合中的元素能够按score进行有序排列  
    可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。  

    + 自动排序  
    + 用户排名等  
        比如按照用户投票时间来排序等等场景。  
    + 排行榜/top n  
    + 构建有优先级的队列系统  

6. 计数器  
    全局增量ID生成，类似“秒杀”  
7. 验证重复访问  
    验证前端的重复请求（可以自由扩展类似情况），可以通过redis进行过滤：每次请求将request Ip、参数、接口等hash作为key存储redis（幂等性请求），设置多长时间有效期，  
    然后下次请求过来的时候先在redis中检索有没有这个key，进而验证是不是一定时间内过来的重复提交  
8. 秒杀  
    list  
    由于 Redis 是单线程模型，lua 可以保证多个命令的原子性。  
