1.jdk配置
2. keytools
3. list
4. jpql
5. java泛型
6. JPA
7. 实参个数可变



................................................................
1.jdk配置：
classpath
C:\Program Files(x86)\Java\jdk1.6.0_19\lib\rt.jar;
C:\Program Files (x86)\Java\jdk1.6.0_19\lib\tools.jar;
D:\tomcat\apache-tomcat-7.0.32;D:\tomcat\apache-tomcat-6.0.35

java_home
C:\Program Files (x86)\Java\jdk1.6.0_19


path
%M2%;%JAVA_HOME%\bin;
C:\Program Files (x86)\Microsoft Visual Studio\Common\Tools\WinNT;
C:\Program Files (x86)\Microsoft Visual Studio\Common\MSDev98\Bin;
C:\Program Files (x86)\Microsoft Visual Studio\Common\Tools;
c:\Program Files (x86)\Microsoft SQL Server\90\Tools\binn\;
C:\Program Files (x86)\Microsoft SQL Server\100\Tools\Binn\;
C:\Program Files\Microsoft SQL Server\100\Tools\Binn\;
C:\Program Files\Microsoft SQL Server\100\DTS\Binn\;
C:\Program Files (x86)\Microsoft SQL Server\100\Tools\Binn\VSShell\Common7\IDE\;
C:\Program Files (x86)\Microsoft SQL Server\100\DTS\Binn\;C:\Program Files (x86)\Microsoft Visual Studio 9.0\Common7\IDE\PrivateAssemblies\;D:\mysqlserver32\mysql-5.1.66-winx64\bin

...............................................................
2. keytools
jdk密钥生成工具

Keytool是一个Java数据证书的管理工具。

keystore 
Keytool将密钥（key）和证书（certificates）
存在一个称为keystore的文件中 
在keystore里，包含两种数据： 
密钥实体（Key entity）――密钥（secret key）
又或者是私钥和配对公钥（采用非对称加密） 
可信任的证书实体（trusted certificate entries）――只包含公钥 

Alias（别名） 
每个keystore都关联这一个独一无二的alias，这个alias通常不区分大小写 

cacerts证书文件(The cacerts Certificates File) 
改证书文件存在于java.home\lib\security目录下，是Java系统的CA证书仓库 

%Java_home%\bin\keytool -genkey -alias tomcat -keyalg RSA

................................................................
3. list
list使用

example:/applicationtest/src/test/cust/project/UserList.java

list<class>
List接口的常用实现类有ArrayList和LinkedList，
在使用List集合时，通常情况下声明为List类型，
实例化时根据实际情况的需要，实例化为ArrayList或LinkedList，
例如：
List<String> l = new ArrayList<String>();
// 利用ArrayList类实例化List集合
List<String> l2 = new LinkedList<String>();
// 利用LinkedList类实例化List集合

..................................................................
4. jpql
JPQL全称Java Persistence Query Language Java持久化查询语言

特点：
其特征与原生SQL语句类似，并且完全面向对象，通过类名和属性访问，
而不是表名和表的属性。


select name ,age from user; //原生SQL语句
select u.name,u.age from User u;  //JPQL语句
select u from User u;  //JPQL语句

SQL语句是在数据库空间中对字段，列，行进行操作
JPQL语句是在EJB实体空间中面向对象,属性进行操作
JPQL必须由JPA的JPQL解析器解析为SQL才能执行，必须先获取Query对象

.................................................................
5. java泛型

http://www.w3cschool.cc/

泛型（Generic type 或者 generics）是对 
Java 语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类。

example:
public void write(Integer i, Integer[] ia);
public void write(Double  d, Double[] da);
的范型版本为
public <T> void write(T t, T[] ta);



.................................................................
6. JPA

http://blog.csdn.net/hmk2011/article/details/6289151
http://docs.oracle.com/javaee/5/api/javax/persistence/Query.html#getResultList%28%29

JPA全称Java Persistence API.
JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，
并将运行期的实体对象持久化到数据库中。

JPA的查询语言是面向对象而非面向数据库的，
它以面向对象的自然语法构造查询语句，
可以看成是Hibernate HQL的等价物。
JPA定义了独特的JPQL（Java Persistence Query Language），
JPQL是EJB QL的一种扩展，它是针对实体的一种查询语言，
操作对象是实体，而不是关系数据库的表，
而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 
SQL 才能够提供的高级查询特性，甚至还能够支持子查询。

hibernate and JPA
JPA是需要Provider来实现其功能的，
Hibernate就是JPA Provider中很强的一个，
应该说无人能出其右。从功能上来说，
JPA就是Hibernate功能的一个子集。
Hibernate 从3.2开始，就开始兼容JPA。

Spring  and JPA 
Spring 2.0.1中，正式提供对JPA的支持

通过将@PersistenceContext注解标注在EntityManager类型的字段上，
这样得到的EntityManager就是容器管理的EntityManager。
由于是容器管理的，所以我们不需要也不应该显式关闭注入的EntityManager实例。
persistence.xml
...............
<?xml version="1.0" encoding="UTF-8"?>   
<persistence version="1.0"  
xmlns:persistence="http://java.sun.com/xml/ns/persistence"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xsi:schemaLocation="http://java.sun.com/xml/ns/persistence persistence_1_0.xsd ">    
<!--    
     Name属性用于定义持久化单元的名字 (name必选,空值也合法);   
     transaction-type 指定事务类型(可选)    
-->  
<persistence-unit name="unitName" transaction-type="JTA">    
   <!-- 描述信息.(可选) -->  
   <description> </description>    
   <!-- javax.persistence.PersistenceProvider接口的一个实现类(可选) -->  
   <provider>   </provider>    
   <!-- Jta-data-source和 non-jta-data-source用于分别指定持久化提供商使用的JTA和/或non-JTA数据源的全局JNDI名称(可选) -->  
   <jta-data-source>java:/MySqlDS</jta-data-source>  
   <non-jta-data-source> </non-jta-data-source>    
   <!-- 声明orm.xml所在位置.(可选) -->  
   <mapping-file>product.xml</mapping-file>    
   <!-- 以包含persistence.xml的jar文件为基准的相对路径,添加额外的jar文件.(可选) -->  
   <jar-file>../lib/model.jar</jar-file>    
   <!-- 显式列出实体类,在Java SE 环境中应该显式列出.(可选) -->  
   <class>com.domain.User</class>  
   <class>com.domain.Product</class>   
   <!-- 声明是否扫描jar文件中标注了@Enity类加入到上下文.若不扫描,则如下:(可选) -->  
   <exclude-unlisted-classes/>   
   <!--   厂商专有属性(可选)   -->  
   <properties>  
    <!-- hibernate.hbm2ddl.auto= create-drop / create / update -->  
    <property name="hibernate.hbm2ddl.auto" value="update" />  
    <property name="hibernate.show_sql" value="true" />  
   </properties>   
</persistence-unit>   
</persistence>
..............

ORM
ORM 是Object-Relation-Mapping，
即对象关系影射技术，是对象持久化的核心。
ORM是对JDBC的封装，从而解决了JDBC的各种存在问题

EntityManager
EntityManager 是用来对实体Bean 进行操作的辅助类。
他可以用来产生/删除持久化的实体Bean，
通过主键查找实体bean，也可以通过EJB3 QL 语言查找满足条件的实体Bean。
实体Bean 被EntityManager 管理时，
EntityManager跟踪他的状态改变，
在任何决定更新实体Bean 的时候便会把发生改变的值同步到数据库中。
当实体Bean 从EntityManager 分离后，他是不受管理的，
EntityManager 无法跟踪他的任何状态改变。
EntityManager 的获取前面已经介绍过，
可以通过@PersistenceContext 注释由EJB 容器动态注入.

Entity的获取
  find(*.class,ID) :若实体Bean不存在,则返回null
getReference(*,class,ID) :若实体Bean不存在,
则抛出javax.persistence.EntityNotFoundException
  persist() :添加实体Bean
  merge () :是在实体Bean 已经脱离了EntityManager 的管理时使用，
当容器决定flush 时，数据将会同步到数据库中.
  Remove() :删除对象
  createQuery() 返回Query对象,以执行JPQL语句
  createNativeQuery() 返回Query对象,以执行SQL语句
  refresh() 刷新实体Bean,以得到对新对象
  contains() 检测实体当前是否被管理
  flush() 将实体的改变立刻刷新到数据库中


..........................................................................
7. 实参个数可变

定义实参个数可变的方法
只要在一个形参的“类型”与“参数名”之间加上三个
连续的“.”（即“...”，英文里的句中省略号），就可以让它和不确定
个实参相匹配。而一个带有这样的形参的方法，就是一个实参个数可变的方法。
一个实参个数可变的方法
private static int sumUp(int... values) {}

Object... params
new Object[]{para1, para2, para3 }等同于这样的形式。

private static int sumUp(int... values) {
    int sum = 0;
    for (int i = 0; i < values.length; i++) {
        sum += values[i];
    }
    return sum;
}
public static void generalUse(int []args){  
        for (int i = 0;i < args.length ; i++ ){  
                System.out.println(args[i]);  
        }  
    }   
public static void newBehaviour(int... args){  
        for (int i = 0;i < args.length ; i++ ){  
                System.out.println(args[i]);  
        }  
    }   

............................................................................
8.
